{"ast":null,"code":"import React, { forwardRef, useState, useRef, useId, useImperativeHandle, useCallback, useEffect, Children } from 'react';\nimport { findFirstFocusableNodeIncludingDisabled, focusNextFocusableNode } from '../../utilities/focus.js';\nimport { portal } from '../shared.js';\nimport { setActivatorAttributes } from './set-activator-attributes.js';\nimport { PopoverCloseSource, PopoverOverlay } from './components/PopoverOverlay/PopoverOverlay.js';\nimport { Pane } from './components/Pane/Pane.js';\nimport { Section } from './components/Section/Section.js';\nimport { Portal } from '../Portal/Portal.js';\n\n// TypeScript can't generate types that correctly infer the typing of\n// subcomponents so explicitly state the subcomponents in the type definition.\n// Letting this be implicit works in this project but fails in projects that use\n// generated *.d.ts files.\n\nconst PopoverComponent = /*#__PURE__*/forwardRef(function Popover(_ref, ref) {\n  let {\n    activatorWrapper = 'div',\n    children,\n    onClose,\n    activator,\n    preventFocusOnClose,\n    active,\n    fixed,\n    ariaHaspopup,\n    preferInputActivator = true,\n    zIndexOverride,\n    ...rest\n  } = _ref;\n  const [isDisplayed, setIsDisplay] = useState(false);\n  const [activatorNode, setActivatorNode] = useState();\n  const overlayRef = useRef(null);\n  const activatorContainer = useRef(null);\n  const WrapperComponent = activatorWrapper;\n  const id = useId();\n  function forceUpdatePosition() {\n    overlayRef.current?.forceUpdatePosition();\n  }\n  const handleClose = source => {\n    onClose(source);\n    if (activatorContainer.current == null || preventFocusOnClose) {\n      return;\n    }\n    if (source === PopoverCloseSource.FocusOut && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (!focusNextFocusableNode(focusableActivator, isInPortal)) {\n        focusableActivator.focus();\n      }\n    } else if (source === PopoverCloseSource.EscapeKeypress && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (focusableActivator) {\n        focusableActivator.focus();\n      } else {\n        focusNextFocusableNode(focusableActivator, isInPortal);\n      }\n    }\n  };\n  useImperativeHandle(ref, () => {\n    return {\n      forceUpdatePosition,\n      close: function () {\n        let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'activator';\n        const source = target === 'activator' ? PopoverCloseSource.EscapeKeypress : PopoverCloseSource.FocusOut;\n        handleClose(source);\n      }\n    };\n  });\n  const setAccessibilityAttributes = useCallback(() => {\n    if (activatorContainer.current == null) {\n      return;\n    }\n    const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.current);\n    const focusableActivator = firstFocusable || activatorContainer.current;\n    const activatorDisabled = 'disabled' in focusableActivator && Boolean(focusableActivator.disabled);\n    setActivatorAttributes(focusableActivator, {\n      id,\n      active,\n      ariaHaspopup,\n      activatorDisabled\n    });\n  }, [id, active, ariaHaspopup]);\n  useEffect(() => {\n    function setDisplayState() {\n      /**\n       * This is a workaround to prevent rendering the Popover when the content is moved into\n       * a React portal that hasn't been rendered. We don't want to render the Popover in this\n       * case because the auto-focus logic will break. We wait until the activatorContainer is\n       * displayed, which is when it has an offsetParent, or if the activatorContainer is the\n       * body, if it has a clientWidth bigger than 0.\n       * See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n       */\n\n      setIsDisplay(Boolean(activatorContainer.current && (activatorContainer.current.offsetParent !== null || activatorContainer.current === activatorContainer.current.ownerDocument.body && activatorContainer.current.clientWidth > 0)));\n    }\n    if (!activatorContainer.current) {\n      return;\n    }\n    const observer = new ResizeObserver(setDisplayState);\n    observer.observe(activatorContainer.current);\n    setDisplayState();\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n  useEffect(() => {\n    if (!activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    } else if (activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  useEffect(() => {\n    if (activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  const portal = activatorNode && isDisplayed ? /*#__PURE__*/React.createElement(Portal, {\n    idPrefix: \"popover\"\n  }, /*#__PURE__*/React.createElement(PopoverOverlay, Object.assign({\n    ref: overlayRef,\n    id: id,\n    activator: activatorNode,\n    preferInputActivator: preferInputActivator,\n    onClose: handleClose,\n    active: active,\n    fixed: fixed,\n    zIndexOverride: zIndexOverride\n  }, rest), children)) : null;\n  return /*#__PURE__*/React.createElement(WrapperComponent, {\n    ref: activatorContainer\n  }, Children.only(activator), portal);\n});\nfunction isInPortal(element) {\n  let parentElement = element.parentElement;\n  while (parentElement) {\n    if (parentElement.matches(portal.selector)) return false;\n    parentElement = parentElement.parentElement;\n  }\n  return true;\n}\nconst Popover = Object.assign(PopoverComponent, {\n  Pane,\n  Section\n});\nexport { Popover, PopoverCloseSource };","map":{"version":3,"names":["React","forwardRef","useState","useRef","useId","useImperativeHandle","useCallback","useEffect","Children","findFirstFocusableNodeIncludingDisabled","focusNextFocusableNode","portal","setActivatorAttributes","PopoverCloseSource","PopoverOverlay","Pane","Section","Portal","PopoverComponent","Popover","_ref","ref","activatorWrapper","children","onClose","activator","preventFocusOnClose","active","fixed","ariaHaspopup","preferInputActivator","zIndexOverride","rest","isDisplayed","setIsDisplay","activatorNode","setActivatorNode","overlayRef","activatorContainer","WrapperComponent","id","forceUpdatePosition","current","handleClose","source","FocusOut","focusableActivator","isInPortal","focus","EscapeKeypress","close","target","arguments","length","undefined","setAccessibilityAttributes","firstFocusable","activatorDisabled","Boolean","disabled","setDisplayState","offsetParent","ownerDocument","body","clientWidth","observer","ResizeObserver","observe","disconnect","firstElementChild","contains","createElement","idPrefix","Object","assign","only","element","parentElement","matches","selector"],"sources":["D:/tesst/test/node_modules/@shopify/polaris/build/esm/components/Popover/Popover.js"],"sourcesContent":["import React, { forwardRef, useState, useRef, useId, useImperativeHandle, useCallback, useEffect, Children } from 'react';\nimport { findFirstFocusableNodeIncludingDisabled, focusNextFocusableNode } from '../../utilities/focus.js';\nimport { portal } from '../shared.js';\nimport { setActivatorAttributes } from './set-activator-attributes.js';\nimport { PopoverCloseSource, PopoverOverlay } from './components/PopoverOverlay/PopoverOverlay.js';\nimport { Pane } from './components/Pane/Pane.js';\nimport { Section } from './components/Section/Section.js';\nimport { Portal } from '../Portal/Portal.js';\n\n// TypeScript can't generate types that correctly infer the typing of\n// subcomponents so explicitly state the subcomponents in the type definition.\n// Letting this be implicit works in this project but fails in projects that use\n// generated *.d.ts files.\n\nconst PopoverComponent = /*#__PURE__*/forwardRef(function Popover({\n  activatorWrapper = 'div',\n  children,\n  onClose,\n  activator,\n  preventFocusOnClose,\n  active,\n  fixed,\n  ariaHaspopup,\n  preferInputActivator = true,\n  zIndexOverride,\n  ...rest\n}, ref) {\n  const [isDisplayed, setIsDisplay] = useState(false);\n  const [activatorNode, setActivatorNode] = useState();\n  const overlayRef = useRef(null);\n  const activatorContainer = useRef(null);\n  const WrapperComponent = activatorWrapper;\n  const id = useId();\n  function forceUpdatePosition() {\n    overlayRef.current?.forceUpdatePosition();\n  }\n  const handleClose = source => {\n    onClose(source);\n    if (activatorContainer.current == null || preventFocusOnClose) {\n      return;\n    }\n    if (source === PopoverCloseSource.FocusOut && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (!focusNextFocusableNode(focusableActivator, isInPortal)) {\n        focusableActivator.focus();\n      }\n    } else if (source === PopoverCloseSource.EscapeKeypress && activatorNode) {\n      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;\n      if (focusableActivator) {\n        focusableActivator.focus();\n      } else {\n        focusNextFocusableNode(focusableActivator, isInPortal);\n      }\n    }\n  };\n  useImperativeHandle(ref, () => {\n    return {\n      forceUpdatePosition,\n      close: (target = 'activator') => {\n        const source = target === 'activator' ? PopoverCloseSource.EscapeKeypress : PopoverCloseSource.FocusOut;\n        handleClose(source);\n      }\n    };\n  });\n  const setAccessibilityAttributes = useCallback(() => {\n    if (activatorContainer.current == null) {\n      return;\n    }\n    const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.current);\n    const focusableActivator = firstFocusable || activatorContainer.current;\n    const activatorDisabled = 'disabled' in focusableActivator && Boolean(focusableActivator.disabled);\n    setActivatorAttributes(focusableActivator, {\n      id,\n      active,\n      ariaHaspopup,\n      activatorDisabled\n    });\n  }, [id, active, ariaHaspopup]);\n  useEffect(() => {\n    function setDisplayState() {\n      /**\n       * This is a workaround to prevent rendering the Popover when the content is moved into\n       * a React portal that hasn't been rendered. We don't want to render the Popover in this\n       * case because the auto-focus logic will break. We wait until the activatorContainer is\n       * displayed, which is when it has an offsetParent, or if the activatorContainer is the\n       * body, if it has a clientWidth bigger than 0.\n       * See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n       */\n\n      setIsDisplay(Boolean(activatorContainer.current && (activatorContainer.current.offsetParent !== null || activatorContainer.current === activatorContainer.current.ownerDocument.body && activatorContainer.current.clientWidth > 0)));\n    }\n    if (!activatorContainer.current) {\n      return;\n    }\n    const observer = new ResizeObserver(setDisplayState);\n    observer.observe(activatorContainer.current);\n    setDisplayState();\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n  useEffect(() => {\n    if (!activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    } else if (activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  useEffect(() => {\n    if (activatorNode && activatorContainer.current) {\n      setActivatorNode(activatorContainer.current.firstElementChild);\n    }\n    setAccessibilityAttributes();\n  }, [activatorNode, setAccessibilityAttributes]);\n  const portal = activatorNode && isDisplayed ? /*#__PURE__*/React.createElement(Portal, {\n    idPrefix: \"popover\"\n  }, /*#__PURE__*/React.createElement(PopoverOverlay, Object.assign({\n    ref: overlayRef,\n    id: id,\n    activator: activatorNode,\n    preferInputActivator: preferInputActivator,\n    onClose: handleClose,\n    active: active,\n    fixed: fixed,\n    zIndexOverride: zIndexOverride\n  }, rest), children)) : null;\n  return /*#__PURE__*/React.createElement(WrapperComponent, {\n    ref: activatorContainer\n  }, Children.only(activator), portal);\n});\nfunction isInPortal(element) {\n  let parentElement = element.parentElement;\n  while (parentElement) {\n    if (parentElement.matches(portal.selector)) return false;\n    parentElement = parentElement.parentElement;\n  }\n  return true;\n}\nconst Popover = Object.assign(PopoverComponent, {\n  Pane,\n  Section\n});\n\nexport { Popover, PopoverCloseSource };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}