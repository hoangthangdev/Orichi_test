{"ast":null,"code":"import { Rect } from '../../../utilities/geometry.js';\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed) {\n  let topBarOffset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAboveCover = Math.min(spaceAbove + activatorRect.height, desiredHeight);\n  const heightIfBelowCover = Math.min(spaceBelow + activatorRect.height, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n  const positionIfCoverBelow = {\n    height: heightIfBelowCover - verticalMargins,\n    top: activatorTop + containerRectTop,\n    positioning: 'cover'\n  };\n  const positionIfCoverAbove = {\n    height: heightIfAboveCover - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove + activatorRect.height + verticalMargins,\n    positioning: 'cover'\n  };\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n  if (preferredPosition === 'cover') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow + activatorRect.height > desiredHeight || spaceBelow > spaceAbove) ? positionIfCoverBelow : positionIfCoverAbove;\n  }\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect) {\n  let viewport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : windowRect();\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect(node) {\n  const document = node?.ownerDocument || globalThis.document;\n  const window = document.defaultView || globalThis.window;\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };","map":{"version":3,"names":["Rect","calculateVerticalPosition","activatorRect","overlayRect","overlayMargins","scrollableContainerRect","containerRect","preferredPosition","fixed","topBarOffset","arguments","length","undefined","activatorTop","top","activatorBottom","height","spaceAbove","spaceBelow","desiredHeight","verticalMargins","activator","container","minimumSpaceToScroll","distanceToTopScroll","Math","max","distanceToBottomScroll","min","enoughSpaceFromTopScroll","enoughSpaceFromBottomScroll","heightIfAbove","heightIfBelow","heightIfAboveCover","heightIfBelowCover","containerRectTop","positionIfAbove","positioning","positionIfBelow","positionIfCoverBelow","positionIfCoverAbove","calculateHorizontalPosition","preferredAlignment","maximum","width","left","horizontal","activatorRight","center","x","rectIsOutsideOfRect","inner","outer","y","intersectionWithViewport","rect","viewport","windowRect","bottom","right","node","document","ownerDocument","globalThis","window","defaultView","scrollY","scrollX","innerHeight","body","clientWidth"],"sources":["D:/tesst/test/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/utilities/math.js"],"sourcesContent":["import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAboveCover = Math.min(spaceAbove + activatorRect.height, desiredHeight);\n  const heightIfBelowCover = Math.min(spaceBelow + activatorRect.height, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n  const positionIfCoverBelow = {\n    height: heightIfBelowCover - verticalMargins,\n    top: activatorTop + containerRectTop,\n    positioning: 'cover'\n  };\n  const positionIfCoverAbove = {\n    height: heightIfAboveCover - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove + activatorRect.height + verticalMargins,\n    positioning: 'cover'\n  };\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n  if (preferredPosition === 'cover') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow + activatorRect.height > desiredHeight || spaceBelow > spaceAbove) ? positionIfCoverBelow : positionIfCoverAbove;\n  }\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect, viewport = windowRect()) {\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect(node) {\n  const document = node?.ownerDocument || globalThis.document;\n  const window = document.defaultView || globalThis.window;\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}