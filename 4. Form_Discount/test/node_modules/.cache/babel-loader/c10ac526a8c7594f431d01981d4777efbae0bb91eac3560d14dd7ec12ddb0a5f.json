{"ast":null,"code":"import { isElementInViewport } from './is-element-in-viewport.js';\nconst FOCUSABLE_SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled=\"true\"]):not([tabindex=\"-1\"]):not(:disabled),*[tabindex]';\nconst KEYBOARD_FOCUSABLE_SELECTORS = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled=\"true\"]):not([tabindex=\"-1\"]):not(:disabled),*[tabindex]:not([tabindex=\"-1\"])';\nconst MENUITEM_FOCUSABLE_SELECTORS = 'a[role=\"menuitem\"],frame[role=\"menuitem\"],iframe[role=\"menuitem\"],input[role=\"menuitem\"]:not([type=hidden]):not(:disabled),select[role=\"menuitem\"]:not(:disabled),textarea[role=\"menuitem\"]:not(:disabled),button[role=\"menuitem\"]:not(:disabled),*[tabindex]:not([tabindex=\"-1\"])';\nconst handleMouseUpByBlurring = _ref => {\n  let {\n    currentTarget\n  } = _ref;\n  return currentTarget.blur();\n};\nfunction nextFocusableNode(node, filter) {\n  const allFocusableElements = [...document.querySelectorAll(FOCUSABLE_SELECTOR)];\n  const sliceLocation = allFocusableElements.indexOf(node) + 1;\n  const focusableElementsAfterNode = allFocusableElements.slice(sliceLocation);\n  for (const focusableElement of focusableElementsAfterNode) {\n    if (isElementInViewport(focusableElement) && (!filter || filter && filter(focusableElement))) {\n      return focusableElement;\n    }\n  }\n  return null;\n}\nfunction findFirstFocusableNode(element) {\n  let onlyDescendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (!onlyDescendants && matches(element, FOCUSABLE_SELECTOR)) {\n    return element;\n  }\n  return element.querySelector(FOCUSABLE_SELECTOR);\n}\n\n// Popover needs to be able to find its activator even if it is disabled, which FOCUSABLE_SELECTOR doesn't support.\nfunction findFirstFocusableNodeIncludingDisabled(element) {\n  const focusableSelector = `a,button,frame,iframe,input:not([type=hidden]),select,textarea,*[tabindex]`;\n  if (matches(element, focusableSelector)) {\n    return element;\n  }\n  return element.querySelector(focusableSelector);\n}\nfunction focusFirstFocusableNode(element) {\n  let onlyDescendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  findFirstFocusableNode(element, onlyDescendants)?.focus();\n}\nfunction focusNextFocusableNode(node, filter) {\n  const nextFocusable = nextFocusableNode(node, filter);\n  if (nextFocusable && nextFocusable instanceof HTMLElement) {\n    nextFocusable.focus();\n    return true;\n  }\n  return false;\n}\nfunction findFirstKeyboardFocusableNode(element) {\n  let onlyDescendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {\n    return element;\n  }\n  return element.querySelector(KEYBOARD_FOCUSABLE_SELECTORS);\n}\nfunction focusFirstKeyboardFocusableNode(element) {\n  let onlyDescendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const firstFocusable = findFirstKeyboardFocusableNode(element, onlyDescendants);\n  if (firstFocusable) {\n    firstFocusable.focus();\n    return true;\n  }\n  return false;\n}\nfunction findLastKeyboardFocusableNode(element) {\n  let onlyDescendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {\n    return element;\n  }\n  const allFocusable = element.querySelectorAll(KEYBOARD_FOCUSABLE_SELECTORS);\n  return allFocusable[allFocusable.length - 1];\n}\nfunction focusLastKeyboardFocusableNode(element) {\n  let onlyDescendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const lastFocusable = findLastKeyboardFocusableNode(element, onlyDescendants);\n  if (lastFocusable) {\n    lastFocusable.focus();\n    return true;\n  }\n  return false;\n}\nfunction wrapFocusPreviousFocusableMenuItem(parentElement, currentFocusedElement) {\n  const allFocusableChildren = getMenuFocusableDescendants(parentElement);\n  const currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);\n  if (currentItemIdx === -1) {\n    allFocusableChildren[0].focus();\n  } else {\n    allFocusableChildren[(currentItemIdx - 1 + allFocusableChildren.length) % allFocusableChildren.length].focus();\n  }\n}\nfunction wrapFocusNextFocusableMenuItem(parentElement, currentFocusedElement) {\n  const allFocusableChildren = getMenuFocusableDescendants(parentElement);\n  const currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);\n  if (currentItemIdx === -1) {\n    allFocusableChildren[0].focus();\n  } else {\n    allFocusableChildren[(currentItemIdx + 1) % allFocusableChildren.length].focus();\n  }\n}\nfunction getMenuFocusableDescendants(element) {\n  return element.querySelectorAll(MENUITEM_FOCUSABLE_SELECTORS);\n}\nfunction getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement) {\n  let currentItemIdx = 0;\n  for (const focusableChild of allFocusableChildren) {\n    if (focusableChild === currentFocusedElement) {\n      break;\n    }\n    currentItemIdx++;\n  }\n  return currentItemIdx === allFocusableChildren.length ? -1 : currentItemIdx;\n}\nfunction matches(node, selector) {\n  if (node.matches) {\n    return node.matches(selector);\n  }\n  const matches = (node.ownerDocument || document).querySelectorAll(selector);\n  let i = matches.length;\n  while (--i >= 0 && matches.item(i) !== node) return i > -1;\n}\nexport { findFirstFocusableNode, findFirstFocusableNodeIncludingDisabled, findFirstKeyboardFocusableNode, findLastKeyboardFocusableNode, focusFirstFocusableNode, focusFirstKeyboardFocusableNode, focusLastKeyboardFocusableNode, focusNextFocusableNode, handleMouseUpByBlurring, nextFocusableNode, wrapFocusNextFocusableMenuItem, wrapFocusPreviousFocusableMenuItem };","map":{"version":3,"names":["isElementInViewport","FOCUSABLE_SELECTOR","KEYBOARD_FOCUSABLE_SELECTORS","MENUITEM_FOCUSABLE_SELECTORS","handleMouseUpByBlurring","_ref","currentTarget","blur","nextFocusableNode","node","filter","allFocusableElements","document","querySelectorAll","sliceLocation","indexOf","focusableElementsAfterNode","slice","focusableElement","findFirstFocusableNode","element","onlyDescendants","arguments","length","undefined","matches","querySelector","findFirstFocusableNodeIncludingDisabled","focusableSelector","focusFirstFocusableNode","focus","focusNextFocusableNode","nextFocusable","HTMLElement","findFirstKeyboardFocusableNode","focusFirstKeyboardFocusableNode","firstFocusable","findLastKeyboardFocusableNode","allFocusable","focusLastKeyboardFocusableNode","lastFocusable","wrapFocusPreviousFocusableMenuItem","parentElement","currentFocusedElement","allFocusableChildren","getMenuFocusableDescendants","currentItemIdx","getCurrentFocusedElementIndex","wrapFocusNextFocusableMenuItem","focusableChild","selector","ownerDocument","i","item"],"sources":["D:/tesst/test/node_modules/@shopify/polaris/build/esm/utilities/focus.js"],"sourcesContent":["import { isElementInViewport } from './is-element-in-viewport.js';\n\nconst FOCUSABLE_SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled=\"true\"]):not([tabindex=\"-1\"]):not(:disabled),*[tabindex]';\nconst KEYBOARD_FOCUSABLE_SELECTORS = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled=\"true\"]):not([tabindex=\"-1\"]):not(:disabled),*[tabindex]:not([tabindex=\"-1\"])';\nconst MENUITEM_FOCUSABLE_SELECTORS = 'a[role=\"menuitem\"],frame[role=\"menuitem\"],iframe[role=\"menuitem\"],input[role=\"menuitem\"]:not([type=hidden]):not(:disabled),select[role=\"menuitem\"]:not(:disabled),textarea[role=\"menuitem\"]:not(:disabled),button[role=\"menuitem\"]:not(:disabled),*[tabindex]:not([tabindex=\"-1\"])';\nconst handleMouseUpByBlurring = ({\n  currentTarget\n}) => currentTarget.blur();\nfunction nextFocusableNode(node, filter) {\n  const allFocusableElements = [...document.querySelectorAll(FOCUSABLE_SELECTOR)];\n  const sliceLocation = allFocusableElements.indexOf(node) + 1;\n  const focusableElementsAfterNode = allFocusableElements.slice(sliceLocation);\n  for (const focusableElement of focusableElementsAfterNode) {\n    if (isElementInViewport(focusableElement) && (!filter || filter && filter(focusableElement))) {\n      return focusableElement;\n    }\n  }\n  return null;\n}\nfunction findFirstFocusableNode(element, onlyDescendants = true) {\n  if (!onlyDescendants && matches(element, FOCUSABLE_SELECTOR)) {\n    return element;\n  }\n  return element.querySelector(FOCUSABLE_SELECTOR);\n}\n\n// Popover needs to be able to find its activator even if it is disabled, which FOCUSABLE_SELECTOR doesn't support.\nfunction findFirstFocusableNodeIncludingDisabled(element) {\n  const focusableSelector = `a,button,frame,iframe,input:not([type=hidden]),select,textarea,*[tabindex]`;\n  if (matches(element, focusableSelector)) {\n    return element;\n  }\n  return element.querySelector(focusableSelector);\n}\nfunction focusFirstFocusableNode(element, onlyDescendants = true) {\n  findFirstFocusableNode(element, onlyDescendants)?.focus();\n}\nfunction focusNextFocusableNode(node, filter) {\n  const nextFocusable = nextFocusableNode(node, filter);\n  if (nextFocusable && nextFocusable instanceof HTMLElement) {\n    nextFocusable.focus();\n    return true;\n  }\n  return false;\n}\nfunction findFirstKeyboardFocusableNode(element, onlyDescendants = true) {\n  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {\n    return element;\n  }\n  return element.querySelector(KEYBOARD_FOCUSABLE_SELECTORS);\n}\nfunction focusFirstKeyboardFocusableNode(element, onlyDescendants = true) {\n  const firstFocusable = findFirstKeyboardFocusableNode(element, onlyDescendants);\n  if (firstFocusable) {\n    firstFocusable.focus();\n    return true;\n  }\n  return false;\n}\nfunction findLastKeyboardFocusableNode(element, onlyDescendants = true) {\n  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {\n    return element;\n  }\n  const allFocusable = element.querySelectorAll(KEYBOARD_FOCUSABLE_SELECTORS);\n  return allFocusable[allFocusable.length - 1];\n}\nfunction focusLastKeyboardFocusableNode(element, onlyDescendants = true) {\n  const lastFocusable = findLastKeyboardFocusableNode(element, onlyDescendants);\n  if (lastFocusable) {\n    lastFocusable.focus();\n    return true;\n  }\n  return false;\n}\nfunction wrapFocusPreviousFocusableMenuItem(parentElement, currentFocusedElement) {\n  const allFocusableChildren = getMenuFocusableDescendants(parentElement);\n  const currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);\n  if (currentItemIdx === -1) {\n    allFocusableChildren[0].focus();\n  } else {\n    allFocusableChildren[(currentItemIdx - 1 + allFocusableChildren.length) % allFocusableChildren.length].focus();\n  }\n}\nfunction wrapFocusNextFocusableMenuItem(parentElement, currentFocusedElement) {\n  const allFocusableChildren = getMenuFocusableDescendants(parentElement);\n  const currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);\n  if (currentItemIdx === -1) {\n    allFocusableChildren[0].focus();\n  } else {\n    allFocusableChildren[(currentItemIdx + 1) % allFocusableChildren.length].focus();\n  }\n}\nfunction getMenuFocusableDescendants(element) {\n  return element.querySelectorAll(MENUITEM_FOCUSABLE_SELECTORS);\n}\nfunction getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement) {\n  let currentItemIdx = 0;\n  for (const focusableChild of allFocusableChildren) {\n    if (focusableChild === currentFocusedElement) {\n      break;\n    }\n    currentItemIdx++;\n  }\n  return currentItemIdx === allFocusableChildren.length ? -1 : currentItemIdx;\n}\nfunction matches(node, selector) {\n  if (node.matches) {\n    return node.matches(selector);\n  }\n  const matches = (node.ownerDocument || document).querySelectorAll(selector);\n  let i = matches.length;\n  while (--i >= 0 && matches.item(i) !== node) return i > -1;\n}\n\nexport { findFirstFocusableNode, findFirstFocusableNodeIncludingDisabled, findFirstKeyboardFocusableNode, findLastKeyboardFocusableNode, focusFirstFocusableNode, focusFirstKeyboardFocusableNode, focusLastKeyboardFocusableNode, focusNextFocusableNode, handleMouseUpByBlurring, nextFocusableNode, wrapFocusNextFocusableMenuItem, wrapFocusPreviousFocusableMenuItem };\n"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,6BAA6B;AAEjE,MAAMC,kBAAkB,GAAG,yLAAyL;AACpN,MAAMC,4BAA4B,GAAG,8MAA8M;AACnP,MAAMC,4BAA4B,GAAG,oRAAoR;AACzT,MAAMC,uBAAuB,GAAGC,IAAA;EAAA,IAAC;IAC/BC;EACF,CAAC,GAAAD,IAAA;EAAA,OAAKC,aAAa,CAACC,IAAI,CAAC,CAAC;AAAA;AAC1B,SAASC,iBAAiBA,CAACC,IAAI,EAAEC,MAAM,EAAE;EACvC,MAAMC,oBAAoB,GAAG,CAAC,GAAGC,QAAQ,CAACC,gBAAgB,CAACZ,kBAAkB,CAAC,CAAC;EAC/E,MAAMa,aAAa,GAAGH,oBAAoB,CAACI,OAAO,CAACN,IAAI,CAAC,GAAG,CAAC;EAC5D,MAAMO,0BAA0B,GAAGL,oBAAoB,CAACM,KAAK,CAACH,aAAa,CAAC;EAC5E,KAAK,MAAMI,gBAAgB,IAAIF,0BAA0B,EAAE;IACzD,IAAIhB,mBAAmB,CAACkB,gBAAgB,CAAC,KAAK,CAACR,MAAM,IAAIA,MAAM,IAAIA,MAAM,CAACQ,gBAAgB,CAAC,CAAC,EAAE;MAC5F,OAAOA,gBAAgB;IACzB;EACF;EACA,OAAO,IAAI;AACb;AACA,SAASC,sBAAsBA,CAACC,OAAO,EAA0B;EAAA,IAAxBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAC7D,IAAI,CAACD,eAAe,IAAII,OAAO,CAACL,OAAO,EAAEnB,kBAAkB,CAAC,EAAE;IAC5D,OAAOmB,OAAO;EAChB;EACA,OAAOA,OAAO,CAACM,aAAa,CAACzB,kBAAkB,CAAC;AAClD;;AAEA;AACA,SAAS0B,uCAAuCA,CAACP,OAAO,EAAE;EACxD,MAAMQ,iBAAiB,GAAG,4EAA4E;EACtG,IAAIH,OAAO,CAACL,OAAO,EAAEQ,iBAAiB,CAAC,EAAE;IACvC,OAAOR,OAAO;EAChB;EACA,OAAOA,OAAO,CAACM,aAAa,CAACE,iBAAiB,CAAC;AACjD;AACA,SAASC,uBAAuBA,CAACT,OAAO,EAA0B;EAAA,IAAxBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAC9DH,sBAAsB,CAACC,OAAO,EAAEC,eAAe,CAAC,EAAES,KAAK,CAAC,CAAC;AAC3D;AACA,SAASC,sBAAsBA,CAACtB,IAAI,EAAEC,MAAM,EAAE;EAC5C,MAAMsB,aAAa,GAAGxB,iBAAiB,CAACC,IAAI,EAAEC,MAAM,CAAC;EACrD,IAAIsB,aAAa,IAAIA,aAAa,YAAYC,WAAW,EAAE;IACzDD,aAAa,CAACF,KAAK,CAAC,CAAC;IACrB,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AACA,SAASI,8BAA8BA,CAACd,OAAO,EAA0B;EAAA,IAAxBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACrE,IAAI,CAACD,eAAe,IAAII,OAAO,CAACL,OAAO,EAAElB,4BAA4B,CAAC,EAAE;IACtE,OAAOkB,OAAO;EAChB;EACA,OAAOA,OAAO,CAACM,aAAa,CAACxB,4BAA4B,CAAC;AAC5D;AACA,SAASiC,+BAA+BA,CAACf,OAAO,EAA0B;EAAA,IAAxBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACtE,MAAMc,cAAc,GAAGF,8BAA8B,CAACd,OAAO,EAAEC,eAAe,CAAC;EAC/E,IAAIe,cAAc,EAAE;IAClBA,cAAc,CAACN,KAAK,CAAC,CAAC;IACtB,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AACA,SAASO,6BAA6BA,CAACjB,OAAO,EAA0B;EAAA,IAAxBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACpE,IAAI,CAACD,eAAe,IAAII,OAAO,CAACL,OAAO,EAAElB,4BAA4B,CAAC,EAAE;IACtE,OAAOkB,OAAO;EAChB;EACA,MAAMkB,YAAY,GAAGlB,OAAO,CAACP,gBAAgB,CAACX,4BAA4B,CAAC;EAC3E,OAAOoC,YAAY,CAACA,YAAY,CAACf,MAAM,GAAG,CAAC,CAAC;AAC9C;AACA,SAASgB,8BAA8BA,CAACnB,OAAO,EAA0B;EAAA,IAAxBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACrE,MAAMkB,aAAa,GAAGH,6BAA6B,CAACjB,OAAO,EAAEC,eAAe,CAAC;EAC7E,IAAImB,aAAa,EAAE;IACjBA,aAAa,CAACV,KAAK,CAAC,CAAC;IACrB,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AACA,SAASW,kCAAkCA,CAACC,aAAa,EAAEC,qBAAqB,EAAE;EAChF,MAAMC,oBAAoB,GAAGC,2BAA2B,CAACH,aAAa,CAAC;EACvE,MAAMI,cAAc,GAAGC,6BAA6B,CAACH,oBAAoB,EAAED,qBAAqB,CAAC;EACjG,IAAIG,cAAc,KAAK,CAAC,CAAC,EAAE;IACzBF,oBAAoB,CAAC,CAAC,CAAC,CAACd,KAAK,CAAC,CAAC;EACjC,CAAC,MAAM;IACLc,oBAAoB,CAAC,CAACE,cAAc,GAAG,CAAC,GAAGF,oBAAoB,CAACrB,MAAM,IAAIqB,oBAAoB,CAACrB,MAAM,CAAC,CAACO,KAAK,CAAC,CAAC;EAChH;AACF;AACA,SAASkB,8BAA8BA,CAACN,aAAa,EAAEC,qBAAqB,EAAE;EAC5E,MAAMC,oBAAoB,GAAGC,2BAA2B,CAACH,aAAa,CAAC;EACvE,MAAMI,cAAc,GAAGC,6BAA6B,CAACH,oBAAoB,EAAED,qBAAqB,CAAC;EACjG,IAAIG,cAAc,KAAK,CAAC,CAAC,EAAE;IACzBF,oBAAoB,CAAC,CAAC,CAAC,CAACd,KAAK,CAAC,CAAC;EACjC,CAAC,MAAM;IACLc,oBAAoB,CAAC,CAACE,cAAc,GAAG,CAAC,IAAIF,oBAAoB,CAACrB,MAAM,CAAC,CAACO,KAAK,CAAC,CAAC;EAClF;AACF;AACA,SAASe,2BAA2BA,CAACzB,OAAO,EAAE;EAC5C,OAAOA,OAAO,CAACP,gBAAgB,CAACV,4BAA4B,CAAC;AAC/D;AACA,SAAS4C,6BAA6BA,CAACH,oBAAoB,EAAED,qBAAqB,EAAE;EAClF,IAAIG,cAAc,GAAG,CAAC;EACtB,KAAK,MAAMG,cAAc,IAAIL,oBAAoB,EAAE;IACjD,IAAIK,cAAc,KAAKN,qBAAqB,EAAE;MAC5C;IACF;IACAG,cAAc,EAAE;EAClB;EACA,OAAOA,cAAc,KAAKF,oBAAoB,CAACrB,MAAM,GAAG,CAAC,CAAC,GAAGuB,cAAc;AAC7E;AACA,SAASrB,OAAOA,CAAChB,IAAI,EAAEyC,QAAQ,EAAE;EAC/B,IAAIzC,IAAI,CAACgB,OAAO,EAAE;IAChB,OAAOhB,IAAI,CAACgB,OAAO,CAACyB,QAAQ,CAAC;EAC/B;EACA,MAAMzB,OAAO,GAAG,CAAChB,IAAI,CAAC0C,aAAa,IAAIvC,QAAQ,EAAEC,gBAAgB,CAACqC,QAAQ,CAAC;EAC3E,IAAIE,CAAC,GAAG3B,OAAO,CAACF,MAAM;EACtB,OAAO,EAAE6B,CAAC,IAAI,CAAC,IAAI3B,OAAO,CAAC4B,IAAI,CAACD,CAAC,CAAC,KAAK3C,IAAI,EAAE,OAAO2C,CAAC,GAAG,CAAC,CAAC;AAC5D;AAEA,SAASjC,sBAAsB,EAAEQ,uCAAuC,EAAEO,8BAA8B,EAAEG,6BAA6B,EAAER,uBAAuB,EAAEM,+BAA+B,EAAEI,8BAA8B,EAAER,sBAAsB,EAAE3B,uBAAuB,EAAEI,iBAAiB,EAAEwC,8BAA8B,EAAEP,kCAAkC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}